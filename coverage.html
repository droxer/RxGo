
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>backpressure: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/droxer/RxGo/examples/backpressure/backpressure.go (0.0%)</option>
				
				<option value="file1">github.com/droxer/RxGo/examples/basic/basic.go (0.0%)</option>
				
				<option value="file2">github.com/droxer/RxGo/examples/context/context.go (0.0%)</option>
				
				<option value="file3">github.com/droxer/RxGo/internal/publisher/publisher.go (76.7%)</option>
				
				<option value="file4">github.com/droxer/RxGo/internal/publisher/subscription.go (0.0%)</option>
				
				<option value="file5">github.com/droxer/RxGo/internal/scheduler/adapter.go (0.0%)</option>
				
				<option value="file6">github.com/droxer/RxGo/internal/scheduler/eventloop.go (0.0%)</option>
				
				<option value="file7">github.com/droxer/RxGo/internal/scheduler/scheduler.go (0.0%)</option>
				
				<option value="file8">github.com/droxer/RxGo/internal/scheduler/threadpool.go (0.0%)</option>
				
				<option value="file9">github.com/droxer/RxGo/pkg/observable/observable.go (0.0%)</option>
				
				<option value="file10">github.com/droxer/RxGo/pkg/observable/scheduler.go (0.0%)</option>
				
				<option value="file11">github.com/droxer/RxGo/pkg/reactive/publisher.go (0.0%)</option>
				
				<option value="file12">github.com/droxer/RxGo/pkg/rxgo/rxgo.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/droxer/RxGo/pkg/rxgo"
)

type BackpressureSubscriber struct {
        name     string
        received []int
        mu       sync.Mutex
        wg       *sync.WaitGroup
}

func (s *BackpressureSubscriber) Start() <span class="cov0" title="0">{
        fmt.Printf("[%s] Starting subscription\n", s.name)
}</span>

func (s *BackpressureSubscriber) OnNext(value int) <span class="cov0" title="0">{
        s.mu.Lock()
        s.received = append(s.received, value)
        s.mu.Unlock()
        fmt.Printf("[%s] Processing: %d (total: %d)\n", s.name, value, len(s.received))
        time.Sleep(100 * time.Millisecond) // Simulate slow processing
}</span>

func (s *BackpressureSubscriber) OnError(err error) <span class="cov0" title="0">{
        fmt.Printf("[%s] Error: %v\n", s.name, err)
        s.wg.Done()
}</span>

func (s *BackpressureSubscriber) OnCompleted() <span class="cov0" title="0">{
        fmt.Printf("[%s] Completed, received %d items\n", s.name, len(s.received))
        s.wg.Done()
}</span>

func main() <span class="cov0" title="0">{
        fmt.Println("=== Backpressure Example ===")
        var wg sync.WaitGroup
        wg.Add(1)

        subscriber := &amp;BackpressureSubscriber{
                name: "Backpressure",
                wg:   &amp;wg,
        }

        // Create observable
        obs := rxgo.Range(1, 10)
        obs.Subscribe(context.Background(), subscriber)
        wg.Wait()
        fmt.Println("Backpressure example completed!")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "fmt"
        "time"

        "github.com/droxer/RxGo/pkg/observable"
        "github.com/droxer/RxGo/pkg/rxgo"
)

// IntSubscriber demonstrates type-safe subscriber with generics
type IntSubscriber struct {
        name string
}

func (s *IntSubscriber) Start() <span class="cov0" title="0">{
        fmt.Printf("[%s] Starting subscription\n", s.name)
}</span>

func (s *IntSubscriber) OnNext(value int) <span class="cov0" title="0">{
        fmt.Printf("[%s] Received: %d\n", s.name, value)
}</span>

func (s *IntSubscriber) OnError(err error) <span class="cov0" title="0">{
        fmt.Printf("[%s] Error: %v\n", s.name, err)
}</span>

func (s *IntSubscriber) OnCompleted() <span class="cov0" title="0">{
        fmt.Printf("[%s] Completed\n", s.name)
}</span>

func main() <span class="cov0" title="0">{
        fmt.Println("=== RxGo Modern Example ===")

        // Example 1: Basic usage with Just
        fmt.Println("\n1. Using Just():")
        justObservable := rxgo.Just(1, 2, 3, 4, 5)
        justObservable.Subscribe(context.Background(), &amp;IntSubscriber{name: "Just"})

        // Example 2: Range observable
        fmt.Println("\n2. Using Range():")
        rangeObservable := rxgo.Range(10, 5)
        rangeObservable.Subscribe(context.Background(), &amp;IntSubscriber{name: "Range"})

        // Example 3: Create with custom logic
        fmt.Println("\n3. Using Create():")
        customObservable := rxgo.Create(func(ctx context.Context, sub observable.Subscriber[int]) </span><span class="cov0" title="0">{
                for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                sub.OnError(ctx.Err())
                                return</span>
                        default:<span class="cov0" title="0">
                                sub.OnNext(i * 10)</span>
                        }
                }
                <span class="cov0" title="0">sub.OnCompleted()</span>
        })
        <span class="cov0" title="0">customObservable.Subscribe(context.Background(), &amp;IntSubscriber{name: "Create"})

        // Example 4: With context (no scheduler due to event loop issues)
        fmt.Println("\n4. With context cancellation:")
        ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
        defer cancel()

        contextObservable := rxgo.Create(func(ctx context.Context, sub observable.Subscriber[int]) </span><span class="cov0" title="0">{
                for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                sub.OnError(ctx.Err())
                                return</span>
                        default:<span class="cov0" title="0">
                                sub.OnNext(i * 100)</span>
                        }
                }
                <span class="cov0" title="0">sub.OnCompleted()</span>
        })
        <span class="cov0" title="0">contextObservable.Subscribe(ctx, &amp;IntSubscriber{name: "Context"})

        time.Sleep(100 * time.Millisecond)

        fmt.Println("\n=== All examples completed ===")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "fmt"
        "time"

        "github.com/droxer/RxGo/pkg/observable"
        "github.com/droxer/RxGo/pkg/rxgo"
)

type ContextAwareSubscriber struct {
        received int
}

func (s *ContextAwareSubscriber) Start() <span class="cov0" title="0">{
        fmt.Println("Context-aware subscriber started")
}</span>

func (s *ContextAwareSubscriber) OnNext(value int) <span class="cov0" title="0">{
        s.received++
        fmt.Printf("Received: %d\n", value)
}</span>

func (s *ContextAwareSubscriber) OnError(err error) <span class="cov0" title="0">{
        fmt.Printf("Context cancelled: %v\n", err)
}</span>

func (s *ContextAwareSubscriber) OnCompleted() <span class="cov0" title="0">{
        fmt.Printf("Completed, total received: %d\n", s.received)
}</span>

func main() <span class="cov0" title="0">{
        fmt.Println("=== Context Cancellation Example ===")

        ctx, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()

        subscriber := &amp;ContextAwareSubscriber{}

        // Create observable that respects context cancellation
        observable := rxgo.Create(func(ctx context.Context, sub observable.Subscriber[int]) </span><span class="cov0" title="0">{
                defer sub.OnCompleted()
                for i := 1; i &lt;= 100; i++ </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                sub.OnError(ctx.Err())
                                return</span>
                        default:<span class="cov0" title="0">
                                sub.OnNext(i)
                                time.Sleep(10 * time.Millisecond)</span> // Small delay to show cancellation
                        }
                }
        })

        <span class="cov0" title="0">observable.Subscribe(ctx, subscriber)
        time.Sleep(500 * time.Millisecond) // Wait for completion
        fmt.Println("Context cancellation example completed!")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package publisher

import (
        "context"
        "sync/atomic"
)

// Publisher represents a Reactive Streams Publisher that can be subscribed to
type Publisher[T any] interface {
        Subscribe(ctx context.Context, s ReactiveSubscriber[T])
}

// ReactiveSubscriber represents a Reactive Streams Subscriber
// This is the modern, type-safe interface for subscribers
// It follows the Reactive Streams specification 1.0.3
// See: https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md
// The original Reactive Streams specification was designed for JVM, but this is a Go implementation
// that follows the same principles and semantics.
type ReactiveSubscriber[T any] interface {
        OnSubscribe(s Subscription)
        OnNext(t T)
        OnError(err error)
        OnComplete()
}

// Subscription represents the link between Publisher and Subscriber
// This interface is part of the Reactive Streams specification
type Subscription interface {
        Request(n int64)
        Cancel()
}

// ReactivePublisher implements Publisher with full Reactive Streams compliance
// This is the main implementation that provides backpressure support
type ReactivePublisher[T any] struct {
        onSubscribe func(ctx context.Context, sub ReactiveSubscriber[T])
}

// NewReactivePublisher creates a new ReactivePublisher
func NewReactivePublisher[T any](onSubscribe func(ctx context.Context, sub ReactiveSubscriber[T])) *ReactivePublisher[T] <span class="cov8" title="1">{
        return &amp;ReactivePublisher[T]{
                onSubscribe: onSubscribe,
        }
}</span>

// Subscribe implements the Publisher interface
func (p *ReactivePublisher[T]) Subscribe(ctx context.Context, s ReactiveSubscriber[T]) <span class="cov8" title="1">{
        if s == nil </span><span class="cov8" title="1">{
                panic("subscriber cannot be nil")</span>
        }

        // Create subscription
        <span class="cov8" title="1">subscription := &amp;reactiveSubscription{}

        // Notify subscriber of subscription
        s.OnSubscribe(subscription)

        // Start processing in a goroutine
        go func() </span><span class="cov8" title="1">{
                p.processWithBackpressure(ctx, s, subscription)
        }</span>()
}

// processWithBackpressure handles item emission with proper backpressure control
func (p *ReactivePublisher[T]) processWithBackpressure(ctx context.Context, s ReactiveSubscriber[T], sub *reactiveSubscription) <span class="cov8" title="1">{
        // For now, use the direct subscription for simplicity
        p.onSubscribe(ctx, s)
}</span>

// FromSlice creates a Publisher from a slice of values
func FromSlice[T any](items []T) Publisher[T] <span class="cov8" title="1">{
        return NewReactivePublisher(func(ctx context.Context, sub ReactiveSubscriber[T]) </span><span class="cov8" title="1">{
                defer sub.OnComplete()

                for _, item := range items </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                sub.OnError(ctx.Err())
                                return</span>
                        default:<span class="cov8" title="1">
                                sub.OnNext(item)</span>
                        }
                }
        })
}

// RangePublisher creates a Publisher that emits a range of integers
func RangePublisher(start, count int) Publisher[int] <span class="cov8" title="1">{
        return NewReactivePublisher(func(ctx context.Context, sub ReactiveSubscriber[int]) </span><span class="cov8" title="1">{
                defer sub.OnComplete()

                if count &lt;= 0 </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                sub.OnError(ctx.Err())
                                return</span>
                        default:<span class="cov8" title="1">
                                sub.OnNext(start + i)</span>
                        }
                }
        })
}

// reactiveSubscription implements Subscription for reactive publishers
type reactiveSubscription struct {
        cancelled atomic.Bool
        requested atomic.Int64
}

func (s *reactiveSubscription) Request(n int64) <span class="cov8" title="1">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if s.cancelled.Load() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">s.requested.Add(n)</span>
}

func (s *reactiveSubscription) Cancel() <span class="cov8" title="1">{
        s.cancelled.Store(true)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package publisher

import (
        "context"
        "sync"
        "sync/atomic"
)

// SubscriptionState represents the state of a subscription
type SubscriptionState int

const (
        NoSubscription SubscriptionState = iota
        Active
        Cancelled
        Completed
)

// ReactiveSubscription implements Subscription interface
type ReactiveSubscription struct {
        ctx       context.Context
        cancel    context.CancelFunc
        requested int64        // atomic counter for requested items
        state     atomic.Value // SubscriptionState
        mu        sync.RWMutex
        onRequest func(n int64)
        onCancel  func()
}

// NewReactiveSubscription creates a new ReactiveSubscription
func NewReactiveSubscription(ctx context.Context, onRequest func(n int64), onCancel func()) Subscription <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(ctx)
        sub := &amp;ReactiveSubscription{
                ctx:       ctx,
                cancel:    cancel,
                onRequest: onRequest,
                onCancel:  onCancel,
        }
        sub.state.Store(NoSubscription)
        return sub
}</span>

func (s *ReactiveSubscription) Request(n int64) <span class="cov0" title="0">{
        // Rule 3.9: n must be positive
        if n &lt;= 0 </span><span class="cov0" title="0">{
                // Rule 3.9: IllegalArgumentException
                return
        }</span>

        // Rule 3.6: Subscription state check
        <span class="cov0" title="0">currentState := s.state.Load().(SubscriptionState)
        if currentState == Cancelled || currentState == Completed </span><span class="cov0" title="0">{
                return
        }</span>

        // Atomic addition to requested count
        <span class="cov0" title="0">atomic.AddInt64(&amp;s.requested, n)

        // Notify publisher of demand
        if s.onRequest != nil </span><span class="cov0" title="0">{
                s.onRequest(n)
        }</span>
}

func (s *ReactiveSubscription) Cancel() <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        currentState := s.state.Load().(SubscriptionState)
        if currentState == Cancelled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">s.state.Store(Cancelled)
        s.cancel()

        if s.onCancel != nil </span><span class="cov0" title="0">{
                s.onCancel()
        }</span>
}

func (s *ReactiveSubscription) GetRequested() int64 <span class="cov0" title="0">{
        return atomic.LoadInt64(&amp;s.requested)
}</span>

func (s *ReactiveSubscription) DecrementRequested() int64 <span class="cov0" title="0">{
        return atomic.AddInt64(&amp;s.requested, -1)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package scheduler provides internal scheduler implementations for RxGo
package scheduler

import "time"

// Adapter adapts internal scheduler to pkg/observable Scheduler interface
type Adapter struct {
        s Scheduler
}

// NewAdapter creates a new scheduler adapter
func NewAdapter(s Scheduler) *Adapter <span class="cov0" title="0">{
        return &amp;Adapter{s: s}
}</span>

// Schedule schedules a task to run
func (a *Adapter) Schedule(run func()) <span class="cov0" title="0">{
        a.s.Schedule(func() </span><span class="cov0" title="0">{
                run()
        }</span>)
}

// ScheduleAt schedules a task to run after a delay
func (a *Adapter) ScheduleAt(run func(), delay time.Duration) <span class="cov0" title="0">{
        a.s.ScheduleAt(func() </span><span class="cov0" title="0">{
                run()
        }</span>, delay)
}

// ToObservableScheduler adapts internal scheduler to observable scheduler
func ToObservableScheduler(s Scheduler) *Adapter <span class="cov0" title="0">{
        return NewAdapter(s)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package scheduler

import (
        "fmt"
        "time"
)

type eventLoopScheduler struct {
        workers         []*poolWorker
        jobQueue        chan job
        fixedWorkerPool chan chan job
        quit            chan bool
}

func newEventLoopScheduler(maxWorkers int) Scheduler <span class="cov0" title="0">{
        return &amp;eventLoopScheduler{
                workers:         make([]*poolWorker, maxWorkers),
                fixedWorkerPool: make(chan chan job, maxWorkers),
                jobQueue:        make(chan job),
                quit:            make(chan bool),
        }
}</span>

func (s *eventLoopScheduler) Start() <span class="cov0" title="0">{
        for i := 0; i &lt; len(s.workers); i++ </span><span class="cov0" title="0">{
                s.workers[i] = newPoolWorker(s.fixedWorkerPool)
                s.workers[i].start()
        }</span>

        <span class="cov0" title="0">go s.dispatch()</span>
}

func (s *eventLoopScheduler) Stop() <span class="cov0" title="0">{
        s.quit &lt;- true
        for _, worker := range s.workers </span><span class="cov0" title="0">{
                worker.stop()
        }</span>
}

func (s *eventLoopScheduler) Schedule(run Runnable) <span class="cov0" title="0">{
        job := job{
                run: run,
        }
        s.jobQueue &lt;- job
}</span>

func (s *eventLoopScheduler) ScheduleAt(run Runnable, delay time.Duration) <span class="cov0" title="0">{
        job := job{
                run:   run,
                delay: delay,
        }
        s.jobQueue &lt;- job
}</span>

func (s *eventLoopScheduler) dispatch() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case job := &lt;-s.jobQueue:<span class="cov0" title="0">
                        jobChan := &lt;-s.fixedWorkerPool
                        jobChan &lt;- job</span>
                case &lt;-s.quit:<span class="cov0" title="0">
                        return</span>
                }
        }
}

type poolWorker struct {
        fixedWorkerPool chan chan job
        jobChan         chan job
        quit            chan bool
}

func newPoolWorker(fixedWorkerPool chan chan job) *poolWorker <span class="cov0" title="0">{
        return &amp;poolWorker{
                fixedWorkerPool: fixedWorkerPool,
                jobChan:         make(chan job),
                quit:            make(chan bool),
        }
}</span>

func (p *poolWorker) start() <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        p.fixedWorkerPool &lt;- p.jobChan

                        select </span>{
                        case job := &lt;-p.jobChan:<span class="cov0" title="0">
                                time.Sleep(job.delay)
                                func() </span><span class="cov0" title="0">{
                                        defer func() </span><span class="cov0" title="0">{
                                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                        // Log the panic but don't crash the worker
                                                        // In production, you might want to use a proper logger
                                                        fmt.Printf("Worker recovered from panic: %v\n", r)
                                                }</span>
                                        }()
                                        <span class="cov0" title="0">job.run()</span>
                                }()
                        case &lt;-p.quit:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
}

func (p *poolWorker) stop() <span class="cov0" title="0">{
        p.quit &lt;- true
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package scheduler

import (
        "runtime"
        "time"
)

type Runnable func()

type job struct {
        run   Runnable
        delay time.Duration
}

type Scheduler interface {
        Start()
        Stop()
        Schedule(run Runnable)
        ScheduleAt(run Runnable, delay time.Duration)
}

var (
        Computation Scheduler
        IO          Scheduler
)

func init() <span class="cov0" title="0">{
        Computation = newEventLoopScheduler(maxParallelism())
        IO = newThreadPoolScheduler(time.Second * 120)
}</span>

func maxParallelism() int <span class="cov0" title="0">{
        maxProcs := runtime.GOMAXPROCS(0)
        numCpu := runtime.NumCPU()
        if maxProcs &lt; numCpu </span><span class="cov0" title="0">{
                return maxProcs
        }</span>
        <span class="cov0" title="0">return numCpu</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package scheduler

import (
        "fmt"
        "time"
)

type threadPoolScheduler struct {
        workerPool *cachedThreadPool
        jobQueue   chan job
        quit       chan bool
}

func newThreadPoolScheduler(ttl time.Duration) *threadPoolScheduler <span class="cov0" title="0">{
        return &amp;threadPoolScheduler{
                workerPool: newCachedThreadPool(ttl),
                jobQueue:   make(chan job),
                quit:       make(chan bool),
        }
}</span>

func (tps *threadPoolScheduler) Start() <span class="cov0" title="0">{
        go tps.run()
}</span>

func (tps *threadPoolScheduler) Stop() {<span class="cov0" title="0">
}</span>

func (tps *threadPoolScheduler) Schedule(run Runnable) <span class="cov0" title="0">{
        job := job{
                run: run,
        }

        tps.jobQueue &lt;- job
}</span>

func (tps *threadPoolScheduler) ScheduleAt(run Runnable, delay time.Duration) {<span class="cov0" title="0">
}</span>

func (tps *threadPoolScheduler) run() <span class="cov0" title="0">{
        for job := range tps.jobQueue </span><span class="cov0" title="0">{
                tps.workerPool.get() &lt;- job
        }</span>
}

type cachedThreadPool struct {
        ttl          time.Duration
        jobChanQueue chan chan job
}

func newCachedThreadPool(ttl time.Duration) *cachedThreadPool <span class="cov0" title="0">{
        return &amp;cachedThreadPool{
                ttl:          ttl,
                jobChanQueue: make(chan chan job, 10),
        }
}</span>

func (c *cachedThreadPool) get() chan job <span class="cov0" title="0">{
        select </span>{
        case jobChan := &lt;-c.jobChanQueue:<span class="cov0" title="0">
                return jobChan</span>
        default:<span class="cov0" title="0">
                worker := newThreadWorker(c.ttl, c.jobChanQueue)
                worker.start()
                return worker.jobChan</span>
        }
}

type threadWorker struct {
        ttl          time.Duration
        timer        *time.Timer
        jobChanQueue chan chan job
        jobChan      chan job
        quit         chan bool
}

func newThreadWorker(ttl time.Duration, jobChanQueue chan chan job) *threadWorker <span class="cov0" title="0">{
        return &amp;threadWorker{
                ttl:          ttl,
                timer:        time.NewTimer(ttl),
                jobChanQueue: jobChanQueue,
                jobChan:      make(chan job),
                quit:         make(chan bool),
        }
}</span>

func (t *threadWorker) start() <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        t.jobChanQueue &lt;- t.jobChan

                        select </span>{
                        case job := &lt;-t.jobChan:<span class="cov0" title="0">
                                time.Sleep(job.delay)
                                func() </span><span class="cov0" title="0">{
                                        defer func() </span><span class="cov0" title="0">{
                                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                        fmt.Printf("Thread worker recovered from panic: %v\n", r)
                                                }</span>
                                        }()
                                        <span class="cov0" title="0">job.run()</span>
                                }()
                                <span class="cov0" title="0">t.timer.Reset(t.ttl)</span>
                        case &lt;-t.timer.C:<span class="cov0" title="0">
                                t.stop()
                                return</span>
                        case &lt;-t.quit:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
}

func (t *threadWorker) stop() <span class="cov0" title="0">{
        t.quit &lt;- true
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package observable provides the main Observable API for RxGo
package observable

import (
        "context"
        "fmt"
        "runtime/debug"
)

// Subscriber defines the interface for receiving values from an Observable
type Subscriber[T any] interface {
        Start()
        OnNext(next T)
        OnCompleted()
        OnError(e error)
}

// OnSubscribe defines the function signature for creating an Observable
type OnSubscribe[T any] func(ctx context.Context, sub Subscriber[T])

// Observable represents a stream of values that can be observed
// This is the primary API for reactive programming in RxGo
type Observable[T any] struct {
        onSubscribe OnSubscribe[T]
}

// Create creates a new Observable with the given OnSubscribe function
func Create[T any](on OnSubscribe[T]) *Observable[T] <span class="cov0" title="0">{
        return &amp;Observable[T]{onSubscribe: on}
}</span>

// Subscribe starts the Observable and begins emitting values to the Subscriber
func (o *Observable[T]) Subscribe(ctx context.Context, sub Subscriber[T]) <span class="cov0" title="0">{
        if sub == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Ensure context is not nil
        <span class="cov0" title="0">if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        // Start the subscriber
        <span class="cov0" title="0">sub.Start()

        // Ensure panic recovery
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        debug.PrintStack()
                        sub.OnError(fmt.Errorf("panic in observable: %v", r))
                }</span>
        }()

        // Execute the subscription
        <span class="cov0" title="0">o.onSubscribe(ctx, sub)</span>
}

// Just creates an Observable that emits the provided values
func Just[T any](values ...T) *Observable[T] <span class="cov0" title="0">{
        return Create(func(ctx context.Context, sub Subscriber[T]) </span><span class="cov0" title="0">{
                defer sub.OnCompleted()
                for _, value := range values </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                sub.OnError(ctx.Err())
                                return</span>
                        default:<span class="cov0" title="0">
                                sub.OnNext(value)</span>
                        }
                }
        })
}

// Range creates an Observable that emits integers in the specified range
func Range(start, count int) *Observable[int] <span class="cov0" title="0">{
        return Create(func(ctx context.Context, sub Subscriber[int]) </span><span class="cov0" title="0">{
                defer sub.OnCompleted()
                if count &lt;= 0 </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                sub.OnError(ctx.Err())
                                return</span>
                        default:<span class="cov0" title="0">
                                sub.OnNext(start + i)</span>
                        }
                }
        })
}

// Empty creates an Observable that completes without emitting any items
func Empty[T any]() *Observable[T] <span class="cov0" title="0">{
        return Create(func(ctx context.Context, sub Subscriber[T]) </span><span class="cov0" title="0">{
                sub.OnCompleted()
        }</span>)
}

// Error creates an Observable that immediately signals an error
func Error[T any](err error) *Observable[T] <span class="cov0" title="0">{
        return Create(func(ctx context.Context, sub Subscriber[T]) </span><span class="cov0" title="0">{
                sub.OnError(err)
        }</span>)
}

// Never creates an Observable that never signals any event
func Never[T any]() *Observable[T] <span class="cov0" title="0">{
        return Create(func(ctx context.Context, sub Subscriber[T]) </span><span class="cov0" title="0">{
                &lt;-ctx.Done()
        }</span>)
}

// FromSlice creates an Observable from a slice of values
func FromSlice[T any](items []T) *Observable[T] <span class="cov0" title="0">{
        return Create(func(ctx context.Context, sub Subscriber[T]) </span><span class="cov0" title="0">{
                defer sub.OnCompleted()
                for _, item := range items </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                sub.OnError(ctx.Err())
                                return</span>
                        default:<span class="cov0" title="0">
                                sub.OnNext(item)</span>
                        }
                }
        })
}

// ObserveOn schedules the Observable to emit its values on the specified scheduler
func (o *Observable[T]) ObserveOn(scheduler Scheduler) *Observable[T] <span class="cov0" title="0">{
        return Create(func(ctx context.Context, sub Subscriber[T]) </span><span class="cov0" title="0">{
                o.Subscribe(ctx, &amp;observeOnSubscriber[T]{
                        scheduler: scheduler,
                        sub:       sub,
                        ctx:       ctx,
                })
        }</span>)
}

// observeOnSubscriber wraps a subscriber for scheduling
type observeOnSubscriber[T any] struct {
        scheduler Scheduler
        sub       Subscriber[T]
        ctx       context.Context
        started   bool
}

func (o *observeOnSubscriber[T]) Start() <span class="cov0" title="0">{
        if !o.started </span><span class="cov0" title="0">{
                o.started = true
                o.scheduler.Schedule(func() </span><span class="cov0" title="0">{
                        o.sub.Start()
                }</span>)
        }
}

func (o *observeOnSubscriber[T]) OnNext(t T) <span class="cov0" title="0">{
        o.scheduler.Schedule(func() </span><span class="cov0" title="0">{
                if o.ctx.Err() != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">o.sub.OnNext(t)</span>
        })
}

func (o *observeOnSubscriber[T]) OnError(err error) <span class="cov0" title="0">{
        o.scheduler.Schedule(func() </span><span class="cov0" title="0">{
                if o.ctx.Err() != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">o.sub.OnError(err)</span>
        })
}

func (o *observeOnSubscriber[T]) OnCompleted() <span class="cov0" title="0">{
        o.scheduler.Schedule(func() </span><span class="cov0" title="0">{
                if o.ctx.Err() != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">o.sub.OnCompleted()</span>
        })
}

// Map transforms each value emitted by the Observable
func Map[T, R any](source *Observable[T], transform func(T) R) *Observable[R] <span class="cov0" title="0">{
        return Create(func(ctx context.Context, sub Subscriber[R]) </span><span class="cov0" title="0">{
                source.Subscribe(ctx, &amp;mapSubscriber[T, R]{
                        sub:       sub,
                        transform: transform,
                })
        }</span>)
}

// Filter filters values emitted by the Observable
func Filter[T any](source *Observable[T], predicate func(T) bool) *Observable[T] <span class="cov0" title="0">{
        return Create(func(ctx context.Context, sub Subscriber[T]) </span><span class="cov0" title="0">{
                source.Subscribe(ctx, &amp;filterSubscriber[T]{
                        sub:       sub,
                        predicate: predicate,
                })
        }</span>)
}

// mapSubscriber implements the mapping transformation
type mapSubscriber[T, R any] struct {
        sub       Subscriber[R]
        transform func(T) R
}

func (m *mapSubscriber[T, R]) Start()            <span class="cov0" title="0">{ m.sub.Start() }</span>
func (m *mapSubscriber[T, R]) OnNext(t T)        <span class="cov0" title="0">{ m.sub.OnNext(m.transform(t)) }</span>
func (m *mapSubscriber[T, R]) OnError(err error) <span class="cov0" title="0">{ m.sub.OnError(err) }</span>
func (m *mapSubscriber[T, R]) OnCompleted()      <span class="cov0" title="0">{ m.sub.OnCompleted() }</span>

// filterSubscriber implements the filtering transformation
type filterSubscriber[T any] struct {
        sub       Subscriber[T]
        predicate func(T) bool
}

func (f *filterSubscriber[T]) Start() <span class="cov0" title="0">{ f.sub.Start() }</span>
func (f *filterSubscriber[T]) OnNext(t T) <span class="cov0" title="0">{
        if f.predicate(t) </span><span class="cov0" title="0">{
                f.sub.OnNext(t)
        }</span>
}
func (f *filterSubscriber[T]) OnError(err error) <span class="cov0" title="0">{ f.sub.OnError(err) }</span>
func (f *filterSubscriber[T]) OnCompleted()      <span class="cov0" title="0">{ f.sub.OnCompleted() }</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package observable

import "sync"

// Scheduler defines an interface for scheduling work
type Scheduler interface {
        Schedule(task func())
}

// ImmediateScheduler runs tasks immediately on the calling goroutine
type ImmediateScheduler struct{}

func NewImmediateScheduler() *ImmediateScheduler <span class="cov0" title="0">{
        return &amp;ImmediateScheduler{}
}</span>

func (s *ImmediateScheduler) Schedule(task func()) <span class="cov0" title="0">{
        task()
}</span>

// NewThreadScheduler runs each task on a new goroutine
type NewThreadScheduler struct{}

func NewNewThreadScheduler() *NewThreadScheduler <span class="cov0" title="0">{
        return &amp;NewThreadScheduler{}
}</span>

func (s *NewThreadScheduler) Schedule(task func()) <span class="cov0" title="0">{
        go task()
}</span>

// SingleThreadScheduler runs tasks sequentially on a single goroutine
type SingleThreadScheduler struct {
        tasks chan func()
        wg    sync.WaitGroup
}

func NewSingleThreadScheduler() *SingleThreadScheduler <span class="cov0" title="0">{
        s := &amp;SingleThreadScheduler{
                tasks: make(chan func(), 100),
        }
        go s.run()
        return s
}</span>

func (s *SingleThreadScheduler) Schedule(task func()) <span class="cov0" title="0">{
        select </span>{
        case s.tasks &lt;- task:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
                // Channel full, drop task or handle appropriately
        }
}

func (s *SingleThreadScheduler) run() <span class="cov0" title="0">{
        defer s.wg.Done()
        for task := range s.tasks </span><span class="cov0" title="0">{
                task()
        }</span>
}

func (s *SingleThreadScheduler) Close() <span class="cov0" title="0">{
        close(s.tasks)
        s.wg.Wait()
}</span>

// TrampolineScheduler runs tasks on the current goroutine but allows yielding
type TrampolineScheduler struct {
        tasks []func()
}

func NewTrampolineScheduler() *TrampolineScheduler <span class="cov0" title="0">{
        return &amp;TrampolineScheduler{}
}</span>

func (s *TrampolineScheduler) Schedule(task func()) <span class="cov0" title="0">{
        s.tasks = append(s.tasks, task)
}</span>

func (s *TrampolineScheduler) Execute() <span class="cov0" title="0">{
        for len(s.tasks) &gt; 0 </span><span class="cov0" title="0">{
                task := s.tasks[0]
                s.tasks = s.tasks[1:]
                task()
        }</span>
}

func (s *TrampolineScheduler) Clear() <span class="cov0" title="0">{
        s.tasks = nil
}</span>

// DefaultScheduler is the default scheduler implementation
var DefaultScheduler Scheduler = NewImmediateScheduler()
</pre>
		
		<pre class="file" id="file11" style="display: none">package reactive

import (
        "context"

        "github.com/droxer/RxGo/internal/publisher"
)

// Publisher represents a provider of a potentially unbounded number of sequenced elements,
// publishing them according to the demand received from its Subscriber(s).
type Publisher[T any] interface {
        Subscribe(ctx context.Context, s Subscriber[T])
}

// Subscriber is a consumer of elements published by a Publisher.
type Subscriber[T any] interface {
        OnSubscribe(s Subscription)
        OnNext(t T)
        OnError(err error)
        OnComplete()
}

// Subscription represents a one-to-one lifecycle of a Subscriber subscribing to a Publisher.
type Subscription interface {
        Request(n int64)
        Cancel()
}

// Processor represents a processing stage that is both a Subscriber and a Publisher.
type Processor[T, R any] interface {
        Publisher[R]
        Subscriber[T]
}

// NewPublisher creates a new Publisher with Reactive Streams compliance
func NewPublisher[T any](onSubscribe func(ctx context.Context, sub Subscriber[T])) Publisher[T] <span class="cov0" title="0">{
        return &amp;publisherAdapter[T]{
                onSubscribe: onSubscribe,
        }
}</span>

// FromSlice creates a Publisher from a slice of values
func FromSlice[T any](items []T) Publisher[T] <span class="cov0" title="0">{
        return &amp;publisherAdapter[T]{
                onSubscribe: func(ctx context.Context, sub Subscriber[T]) </span><span class="cov0" title="0">{
                        bridge := &amp;subscriberBridge[T]{sub: sub}
                        internalPub := publisher.FromSlice(items)
                        internalPub.Subscribe(ctx, bridge)
                }</span>,
        }
}

// Range creates a Publisher that emits a range of integers
func Range(start, count int) Publisher[int] <span class="cov0" title="0">{
        return &amp;publisherAdapter[int]{
                onSubscribe: func(ctx context.Context, sub Subscriber[int]) </span><span class="cov0" title="0">{
                        bridge := &amp;subscriberBridge[int]{sub: sub}
                        internalPub := publisher.RangePublisher(start, count)
                        internalPub.Subscribe(ctx, bridge)
                }</span>,
        }
}

// Empty creates a Publisher that completes without emitting any items
func Empty[T any]() Publisher[T] <span class="cov0" title="0">{
        return NewPublisher(func(ctx context.Context, sub Subscriber[T]) </span><span class="cov0" title="0">{
                sub.OnSubscribe(&amp;emptySubscription{})
                sub.OnComplete()
        }</span>)
}

// Error creates a Publisher that immediately signals an error
func Error[T any](err error) Publisher[T] <span class="cov0" title="0">{
        return NewPublisher(func(ctx context.Context, sub Subscriber[T]) </span><span class="cov0" title="0">{
                sub.OnSubscribe(&amp;emptySubscription{})
                sub.OnError(err)
        }</span>)
}

// Never creates a Publisher that never signals any event
func Never[T any]() Publisher[T] <span class="cov0" title="0">{
        return NewPublisher(func(ctx context.Context, sub Subscriber[T]) </span><span class="cov0" title="0">{
                sub.OnSubscribe(&amp;emptySubscription{})
                &lt;-ctx.Done()
        }</span>)
}

// Just creates a Publisher that emits the provided values
func Just[T any](values ...T) Publisher[T] <span class="cov0" title="0">{
        return FromSlice(values)
}</span>

// publisherAdapter adapts the reactive API to use internal publishers

type publisherAdapter[T any] struct {
        onSubscribe func(ctx context.Context, sub Subscriber[T])
}

func (a *publisherAdapter[T]) Subscribe(ctx context.Context, sub Subscriber[T]) <span class="cov0" title="0">{
        a.onSubscribe(ctx, sub)
}</span>

// subscriberBridge bridges between reactive.Subscriber and publisher.ReactiveSubscriber

type subscriberBridge[T any] struct {
        sub Subscriber[T]
}

func (b *subscriberBridge[T]) OnSubscribe(s publisher.Subscription) <span class="cov0" title="0">{
        b.sub.OnSubscribe(&amp;subscriptionBridge{internal: s})
}</span>

func (b *subscriberBridge[T]) OnNext(t T) <span class="cov0" title="0">{
        b.sub.OnNext(t)
}</span>

func (b *subscriberBridge[T]) OnError(err error) <span class="cov0" title="0">{
        b.sub.OnError(err)
}</span>

func (b *subscriberBridge[T]) OnComplete() <span class="cov0" title="0">{
        b.sub.OnComplete()
}</span>

// subscriptionBridge bridges between reactive.Subscription and publisher.Subscription

type subscriptionBridge struct {
        internal publisher.Subscription
}

func (b *subscriptionBridge) Request(n int64) <span class="cov0" title="0">{
        b.internal.Request(n)
}</span>

func (b *subscriptionBridge) Cancel() <span class="cov0" title="0">{
        b.internal.Cancel()
}</span>

// emptySubscription is a simple subscription that does nothing

type emptySubscription struct{}

func (e *emptySubscription) Request(n int64) {<span class="cov0" title="0">}</span>
func (e *emptySubscription) Cancel()         {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package rxgo provides the main entry point for the RxGo library.
// This package provides a unified API for both Observable and Reactive Streams patterns.
package rxgo

import (
        "context"

        "github.com/droxer/RxGo/pkg/observable"
        "github.com/droxer/RxGo/pkg/reactive"
)

// Observable API

// Create creates a new Observable with the given OnSubscribe function
func Create[T any](on observable.OnSubscribe[T]) *observable.Observable[T] <span class="cov0" title="0">{
        return observable.Create(on)
}</span>

// Just creates an Observable that emits the provided values
func Just[T any](values ...T) *observable.Observable[T] <span class="cov0" title="0">{
        return observable.Just(values...)
}</span>

// Range creates an Observable that emits integers in the specified range
func Range(start, count int) *observable.Observable[int] <span class="cov0" title="0">{
        return observable.Range(start, count)
}</span>

// FromSlice creates an Observable from a slice of values
func FromSlice[T any](items []T) *observable.Observable[T] <span class="cov0" title="0">{
        return observable.FromSlice(items)
}</span>

// Empty creates an Observable that completes without emitting any items
func Empty[T any]() *observable.Observable[T] <span class="cov0" title="0">{
        return observable.Empty[T]()
}</span>

// Error creates an Observable that immediately signals an error
func Error[T any](err error) *observable.Observable[T] <span class="cov0" title="0">{
        return observable.Error[T](err)
}</span>

// Never creates an Observable that never signals any event
func Never[T any]() *observable.Observable[T] <span class="cov0" title="0">{
        return observable.Never[T]()
}</span>

// Reactive Streams API

// NewPublisher creates a new Publisher with Reactive Streams compliance
func NewPublisher[T any](onSubscribe func(ctx context.Context, sub reactive.Subscriber[T])) reactive.Publisher[T] <span class="cov0" title="0">{
        return reactive.NewPublisher(onSubscribe)
}</span>

// RangePublisher creates a Publisher that emits a range of integers
func RangePublisher(start, count int) reactive.Publisher[int] <span class="cov0" title="0">{
        return reactive.Range(start, count)
}</span>

// FromSlicePublisher creates a Publisher from a slice of values
func FromSlicePublisher[T any](items []T) reactive.Publisher[T] <span class="cov0" title="0">{
        return reactive.FromSlice(items)
}</span>

// EmptyPublisher creates a Publisher that completes without emitting any items
func EmptyPublisher[T any]() reactive.Publisher[T] <span class="cov0" title="0">{
        return reactive.Empty[T]()
}</span>

// ErrorPublisher creates a Publisher that immediately signals an error
func ErrorPublisher[T any](err error) reactive.Publisher[T] <span class="cov0" title="0">{
        return reactive.Error[T](err)
}</span>

// NeverPublisher creates a Publisher that never signals any event
func NeverPublisher[T any]() reactive.Publisher[T] <span class="cov0" title="0">{
        return reactive.Never[T]()
}</span>

// JustPublisher creates a Publisher that emits the provided values
func JustPublisher[T any](values ...T) reactive.Publisher[T] <span class="cov0" title="0">{
        return reactive.Just(values...)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
