
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>backpressure: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/droxer/RxGo/examples/backpressure/backpressure.go (0.0%)</option>
				
				<option value="file1">github.com/droxer/RxGo/examples/basic/basic.go (0.0%)</option>
				
				<option value="file2">github.com/droxer/RxGo/examples/context/context.go (0.0%)</option>
				
				<option value="file3">github.com/droxer/RxGo/internal/publisher/publisher.go (76.7%)</option>
				
				<option value="file4">github.com/droxer/RxGo/internal/publisher/subscription.go (0.0%)</option>
				
				<option value="file5">github.com/droxer/RxGo/internal/scheduler/eventloop.go (3.3%)</option>
				
				<option value="file6">github.com/droxer/RxGo/internal/scheduler/scheduler.go (85.7%)</option>
				
				<option value="file7">github.com/droxer/RxGo/internal/scheduler/threadpool.go (7.1%)</option>
				
				<option value="file8">github.com/droxer/RxGo/pkg/observable/bridge.go (0.0%)</option>
				
				<option value="file9">github.com/droxer/RxGo/pkg/observable/observable.go (15.6%)</option>
				
				<option value="file10">github.com/droxer/RxGo/pkg/rxgo/rxgo.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/droxer/RxGo/pkg/observable"
)

type BackpressureSubscriber struct {
        name     string
        received []int
        mu       sync.Mutex
        wg       *sync.WaitGroup
        requests chan int
}

func (s *BackpressureSubscriber) Start() <span class="cov0" title="0">{
        fmt.Printf("[%s] Starting subscription\n", s.name)
        // Start requesting items with backpressure
        go func() </span><span class="cov0" title="0">{
                for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                        time.Sleep(200 * time.Millisecond)
                        s.requests &lt;- 2 // Request 2 items
                        fmt.Printf("[%s] Requested 2 more items\n", s.name)
                }</span>
        }()
}

func (s *BackpressureSubscriber) OnNext(value int) <span class="cov0" title="0">{
        s.mu.Lock()
        s.received = append(s.received, value)
        s.mu.Unlock()
        fmt.Printf("[%s] Processing: %d (total: %d)\n", s.name, value, len(s.received))
        time.Sleep(100 * time.Millisecond) // Simulate slow processing
}</span>

func (s *BackpressureSubscriber) OnError(err error) <span class="cov0" title="0">{
        fmt.Printf("[%s] Error: %v\n", s.name, err)
        s.wg.Done()
}</span>

func (s *BackpressureSubscriber) OnCompleted() <span class="cov0" title="0">{
        fmt.Printf("[%s] Completed, received %d items\n", s.name, len(s.received))
        s.wg.Done()
}</span>

func main() <span class="cov0" title="0">{
        fmt.Println("=== Backpressure Example ===")
        var wg sync.WaitGroup
        wg.Add(1)

        subscriber := &amp;BackpressureSubscriber{
                name:     "Backpressure",
                wg:       &amp;wg,
                requests: make(chan int, 10),
        }

        // Create observable that respects backpressure through channel buffering
        observable := observable.Create(func(ctx context.Context, sub observable.Subscriber[int]) </span><span class="cov0" title="0">{
                defer sub.OnCompleted()

                // Simulate controlled emission based on consumer speed
                items := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
                for _, item := range items </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                sub.OnError(ctx.Err())
                                return</span>
                        default:<span class="cov0" title="0">
                                sub.OnNext(item)
                                time.Sleep(50 * time.Millisecond)</span> // Simulate producer speed
                        }
                }
        })

        <span class="cov0" title="0">observable.Subscribe(context.Background(), subscriber)
        wg.Wait()
        fmt.Println("Backpressure example completed!")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "fmt"
        "time"

        "github.com/droxer/RxGo/pkg/observable"
)

// IntSubscriber demonstrates type-safe subscriber with generics
type IntSubscriber struct {
        name string
}

func (s *IntSubscriber) Start() <span class="cov0" title="0">{
        fmt.Printf("[%s] Starting subscription\n", s.name)
}</span>

func (s *IntSubscriber) OnNext(value int) <span class="cov0" title="0">{
        fmt.Printf("[%s] Received: %d\n", s.name, value)
}</span>

func (s *IntSubscriber) OnError(err error) <span class="cov0" title="0">{
        fmt.Printf("[%s] Error: %v\n", s.name, err)
}</span>

func (s *IntSubscriber) OnCompleted() <span class="cov0" title="0">{
        fmt.Printf("[%s] Completed\n", s.name)
}</span>

func main() <span class="cov0" title="0">{
        fmt.Println("=== RxGo Modern Example ===")

        // Example 1: Basic usage with Just
        fmt.Println("\n1. Using Just():")
        justObservable := observable.Just(1, 2, 3, 4, 5)
        justObservable.Subscribe(context.Background(), &amp;IntSubscriber{name: "Just"})

        // Example 2: Range observable
        fmt.Println("\n2. Using Range():")
        rangeObservable := observable.Range(10, 5)
        rangeObservable.Subscribe(context.Background(), &amp;IntSubscriber{name: "Range"})

        // Example 3: Create with custom logic
        fmt.Println("\n3. Using Create():")
        customObservable := observable.Create(func(ctx context.Context, sub observable.Subscriber[int]) </span><span class="cov0" title="0">{
                for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                sub.OnError(ctx.Err())
                                return</span>
                        default:<span class="cov0" title="0">
                                sub.OnNext(i * 10)</span>
                        }
                }
                <span class="cov0" title="0">sub.OnCompleted()</span>
        })
        <span class="cov0" title="0">customObservable.Subscribe(context.Background(), &amp;IntSubscriber{name: "Create"})

        // Example 4: With context (no scheduler due to event loop issues)
        fmt.Println("\n4. With context cancellation:")
        ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
        defer cancel()

        contextObservable := observable.Create(func(ctx context.Context, sub observable.Subscriber[int]) </span><span class="cov0" title="0">{
                for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                sub.OnError(ctx.Err())
                                return</span>
                        default:<span class="cov0" title="0">
                                sub.OnNext(i * 100)</span>
                        }
                }
                <span class="cov0" title="0">sub.OnCompleted()</span>
        })
        <span class="cov0" title="0">contextObservable.Subscribe(ctx, &amp;IntSubscriber{name: "Context"})

        time.Sleep(100 * time.Millisecond)

        fmt.Println("\n=== All examples completed ===")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "fmt"
        "time"

        "github.com/droxer/RxGo/pkg/observable"
)

type ContextAwareSubscriber struct {
        received int
}

func (s *ContextAwareSubscriber) Start() <span class="cov0" title="0">{
        fmt.Println("Context-aware subscriber started")
}</span>

func (s *ContextAwareSubscriber) OnNext(value int) <span class="cov0" title="0">{
        s.received++
        fmt.Printf("Received: %d\n", value)
}</span>

func (s *ContextAwareSubscriber) OnError(err error) <span class="cov0" title="0">{
        fmt.Printf("Context cancelled: %v\n", err)
}</span>

func (s *ContextAwareSubscriber) OnCompleted() <span class="cov0" title="0">{
        fmt.Printf("Completed, total received: %d\n", s.received)
}</span>

func main() <span class="cov0" title="0">{
        fmt.Println("=== Context Cancellation Example ===")

        ctx, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()

        subscriber := &amp;ContextAwareSubscriber{}

        // Create observable that respects context cancellation
        observable := observable.Create(func(ctx context.Context, sub observable.Subscriber[int]) </span><span class="cov0" title="0">{
                defer sub.OnCompleted()
                for i := 1; i &lt;= 100; i++ </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                sub.OnError(ctx.Err())
                                return</span>
                        default:<span class="cov0" title="0">
                                sub.OnNext(i)
                                time.Sleep(10 * time.Millisecond)</span> // Small delay to show cancellation
                        }
                }
        })

        <span class="cov0" title="0">observable.Subscribe(ctx, subscriber)
        time.Sleep(500 * time.Millisecond) // Wait for completion
        fmt.Println("Context cancellation example completed!")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package publisher

import (
        "context"
        "sync/atomic"
)

// Publisher represents a Reactive Streams Publisher that can be subscribed to
type Publisher[T any] interface {
        Subscribe(ctx context.Context, s ReactiveSubscriber[T])
}

// ReactiveSubscriber represents a Reactive Streams Subscriber
// This is the modern, type-safe interface for subscribers
// It follows the Reactive Streams specification 1.0.3
// See: https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md
// The original Reactive Streams specification was designed for JVM, but this is a Go implementation
// that follows the same principles and semantics.
type ReactiveSubscriber[T any] interface {
        OnSubscribe(s Subscription)
        OnNext(t T)
        OnError(err error)
        OnComplete()
}

// Subscription represents the link between Publisher and Subscriber
// This interface is part of the Reactive Streams specification
type Subscription interface {
        Request(n int64)
        Cancel()
}

// ReactivePublisher implements Publisher with full Reactive Streams compliance
// This is the main implementation that provides backpressure support
type ReactivePublisher[T any] struct {
        onSubscribe func(ctx context.Context, sub ReactiveSubscriber[T])
}

// NewReactivePublisher creates a new ReactivePublisher
func NewReactivePublisher[T any](onSubscribe func(ctx context.Context, sub ReactiveSubscriber[T])) *ReactivePublisher[T] <span class="cov8" title="1">{
        return &amp;ReactivePublisher[T]{
                onSubscribe: onSubscribe,
        }
}</span>

// Subscribe implements the Publisher interface
func (p *ReactivePublisher[T]) Subscribe(ctx context.Context, s ReactiveSubscriber[T]) <span class="cov8" title="1">{
        if s == nil </span><span class="cov8" title="1">{
                panic("subscriber cannot be nil")</span>
        }

        // Create subscription
        <span class="cov8" title="1">subscription := &amp;reactiveSubscription{}

        // Notify subscriber of subscription
        s.OnSubscribe(subscription)

        // Start processing in a goroutine
        go func() </span><span class="cov8" title="1">{
                p.processWithBackpressure(ctx, s, subscription)
        }</span>()
}

// processWithBackpressure handles item emission with proper backpressure control
func (p *ReactivePublisher[T]) processWithBackpressure(ctx context.Context, s ReactiveSubscriber[T], sub *reactiveSubscription) <span class="cov8" title="1">{
        // For now, use the direct subscription for simplicity
        p.onSubscribe(ctx, s)
}</span>

// FromSlice creates a Publisher from a slice of values
func FromSlice[T any](items []T) Publisher[T] <span class="cov8" title="1">{
        return NewReactivePublisher(func(ctx context.Context, sub ReactiveSubscriber[T]) </span><span class="cov8" title="1">{
                defer sub.OnComplete()

                for _, item := range items </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                sub.OnError(ctx.Err())
                                return</span>
                        default:<span class="cov8" title="1">
                                sub.OnNext(item)</span>
                        }
                }
        })
}

// RangePublisher creates a Publisher that emits a range of integers
func RangePublisher(start, count int) Publisher[int] <span class="cov8" title="1">{
        return NewReactivePublisher(func(ctx context.Context, sub ReactiveSubscriber[int]) </span><span class="cov8" title="1">{
                defer sub.OnComplete()

                if count &lt;= 0 </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                sub.OnError(ctx.Err())
                                return</span>
                        default:<span class="cov8" title="1">
                                sub.OnNext(start + i)</span>
                        }
                }
        })
}

// reactiveSubscription implements Subscription for reactive publishers
type reactiveSubscription struct {
        cancelled atomic.Bool
        requested atomic.Int64
}

func (s *reactiveSubscription) Request(n int64) <span class="cov8" title="1">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if s.cancelled.Load() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">s.requested.Add(n)</span>
}

func (s *reactiveSubscription) Cancel() <span class="cov8" title="1">{
        s.cancelled.Store(true)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package publisher

import (
        "context"
        "sync"
        "sync/atomic"
)

// SubscriptionState represents the state of a subscription
type SubscriptionState int

const (
        NoSubscription SubscriptionState = iota
        Active
        Cancelled
        Completed
)

// ReactiveSubscription implements Subscription interface
type ReactiveSubscription struct {
        ctx       context.Context
        cancel    context.CancelFunc
        requested int64        // atomic counter for requested items
        state     atomic.Value // SubscriptionState
        mu        sync.RWMutex
        onRequest func(n int64)
        onCancel  func()
}

// NewReactiveSubscription creates a new ReactiveSubscription
func NewReactiveSubscription(ctx context.Context, onRequest func(n int64), onCancel func()) Subscription <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(ctx)
        sub := &amp;ReactiveSubscription{
                ctx:       ctx,
                cancel:    cancel,
                onRequest: onRequest,
                onCancel:  onCancel,
        }
        sub.state.Store(NoSubscription)
        return sub
}</span>

func (s *ReactiveSubscription) Request(n int64) <span class="cov0" title="0">{
        // Rule 3.9: n must be positive
        if n &lt;= 0 </span><span class="cov0" title="0">{
                // Rule 3.9: IllegalArgumentException
                return
        }</span>

        // Rule 3.6: Subscription state check
        <span class="cov0" title="0">currentState := s.state.Load().(SubscriptionState)
        if currentState == Cancelled || currentState == Completed </span><span class="cov0" title="0">{
                return
        }</span>

        // Atomic addition to requested count
        <span class="cov0" title="0">atomic.AddInt64(&amp;s.requested, n)

        // Notify publisher of demand
        if s.onRequest != nil </span><span class="cov0" title="0">{
                s.onRequest(n)
        }</span>
}

func (s *ReactiveSubscription) Cancel() <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        currentState := s.state.Load().(SubscriptionState)
        if currentState == Cancelled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">s.state.Store(Cancelled)
        s.cancel()

        if s.onCancel != nil </span><span class="cov0" title="0">{
                s.onCancel()
        }</span>
}

func (s *ReactiveSubscription) GetRequested() int64 <span class="cov0" title="0">{
        return atomic.LoadInt64(&amp;s.requested)
}</span>

func (s *ReactiveSubscription) DecrementRequested() int64 <span class="cov0" title="0">{
        return atomic.AddInt64(&amp;s.requested, -1)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package scheduler

import (
        "fmt"
        "time"
)

type eventLoopScheduler struct {
        workers         []*poolWorker
        jobQueue        chan job
        fixedWorkerPool chan chan job
        quit            chan bool
}

func newEventLoopScheduler(maxWorkers int) Scheduler <span class="cov8" title="1">{
        return &amp;eventLoopScheduler{
                workers:         make([]*poolWorker, maxWorkers),
                fixedWorkerPool: make(chan chan job, maxWorkers),
                jobQueue:        make(chan job),
                quit:            make(chan bool),
        }
}</span>

func (s *eventLoopScheduler) Start() <span class="cov0" title="0">{
        for i := 0; i &lt; len(s.workers); i++ </span><span class="cov0" title="0">{
                s.workers[i] = newPoolWorker(s.fixedWorkerPool)
                s.workers[i].start()
        }</span>

        <span class="cov0" title="0">go s.dispatch()</span>
}

func (s *eventLoopScheduler) Stop() <span class="cov0" title="0">{
        s.quit &lt;- true
        for _, worker := range s.workers </span><span class="cov0" title="0">{
                worker.stop()
        }</span>
}

func (s *eventLoopScheduler) Schedule(run Runnable) <span class="cov0" title="0">{
        job := job{
                run: run,
        }
        s.jobQueue &lt;- job
}</span>

func (s *eventLoopScheduler) ScheduleAt(run Runnable, delay time.Duration) <span class="cov0" title="0">{
        job := job{
                run:   run,
                delay: delay,
        }
        s.jobQueue &lt;- job
}</span>

func (s *eventLoopScheduler) dispatch() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case job := &lt;-s.jobQueue:<span class="cov0" title="0">
                        jobChan := &lt;-s.fixedWorkerPool
                        jobChan &lt;- job</span>
                case &lt;-s.quit:<span class="cov0" title="0">
                        return</span>
                }
        }
}

type poolWorker struct {
        fixedWorkerPool chan chan job
        jobChan         chan job
        quit            chan bool
}

func newPoolWorker(fixedWorkerPool chan chan job) *poolWorker <span class="cov0" title="0">{
        return &amp;poolWorker{
                fixedWorkerPool: fixedWorkerPool,
                jobChan:         make(chan job),
                quit:            make(chan bool),
        }
}</span>

func (p *poolWorker) start() <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        p.fixedWorkerPool &lt;- p.jobChan

                        select </span>{
                        case job := &lt;-p.jobChan:<span class="cov0" title="0">
                                time.Sleep(job.delay)
                                func() </span><span class="cov0" title="0">{
                                        defer func() </span><span class="cov0" title="0">{
                                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                        // Log the panic but don't crash the worker
                                                        // In production, you might want to use a proper logger
                                                        fmt.Printf("Worker recovered from panic: %v\n", r)
                                                }</span>
                                        }()
                                        <span class="cov0" title="0">job.run()</span>
                                }()
                        case &lt;-p.quit:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
}

func (p *poolWorker) stop() <span class="cov0" title="0">{
        p.quit &lt;- true
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package scheduler

import (
        "runtime"
        "time"
)

type Runnable func()

type job struct {
        run   Runnable
        delay time.Duration
}

type Scheduler interface {
        Start()
        Stop()
        Schedule(run Runnable)
        ScheduleAt(run Runnable, delay time.Duration)
}

var (
        Computation Scheduler
        IO          Scheduler
)

func init() <span class="cov8" title="1">{
        Computation = newEventLoopScheduler(maxParallelism())
        IO = newThreadPoolScheduler(time.Second * 120)
}</span>

func maxParallelism() int <span class="cov8" title="1">{
        maxProcs := runtime.GOMAXPROCS(0)
        numCpu := runtime.NumCPU()
        if maxProcs &lt; numCpu </span><span class="cov0" title="0">{
                return maxProcs
        }</span>
        <span class="cov8" title="1">return numCpu</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package scheduler

import (
        "fmt"
        "time"
)

type threadPoolScheduler struct {
        workerPool *cachedThreadPool
        jobQueue   chan job
        quit       chan bool
}

func newThreadPoolScheduler(ttl time.Duration) *threadPoolScheduler <span class="cov8" title="1">{
        return &amp;threadPoolScheduler{
                workerPool: newCachedThreadPool(ttl),
                jobQueue:   make(chan job),
                quit:       make(chan bool),
        }
}</span>

func (tps *threadPoolScheduler) Start() <span class="cov0" title="0">{
        go tps.run()
}</span>

func (tps *threadPoolScheduler) Stop() {<span class="cov0" title="0">
}</span>

func (tps *threadPoolScheduler) Schedule(run Runnable) <span class="cov0" title="0">{
        job := job{
                run: run,
        }

        tps.jobQueue &lt;- job
}</span>

func (tps *threadPoolScheduler) ScheduleAt(run Runnable, delay time.Duration) {<span class="cov0" title="0">
}</span>

func (tps *threadPoolScheduler) run() <span class="cov0" title="0">{
        for job := range tps.jobQueue </span><span class="cov0" title="0">{
                tps.workerPool.get() &lt;- job
        }</span>
}

type cachedThreadPool struct {
        ttl          time.Duration
        jobChanQueue chan chan job
}

func newCachedThreadPool(ttl time.Duration) *cachedThreadPool <span class="cov8" title="1">{
        return &amp;cachedThreadPool{
                ttl:          ttl,
                jobChanQueue: make(chan chan job, 10),
        }
}</span>

func (c *cachedThreadPool) get() chan job <span class="cov0" title="0">{
        select </span>{
        case jobChan := &lt;-c.jobChanQueue:<span class="cov0" title="0">
                return jobChan</span>
        default:<span class="cov0" title="0">
                worker := newThreadWorker(c.ttl, c.jobChanQueue)
                worker.start()
                return worker.jobChan</span>
        }
}

type threadWorker struct {
        ttl          time.Duration
        timer        *time.Timer
        jobChanQueue chan chan job
        jobChan      chan job
        quit         chan bool
}

func newThreadWorker(ttl time.Duration, jobChanQueue chan chan job) *threadWorker <span class="cov0" title="0">{
        return &amp;threadWorker{
                ttl:          ttl,
                timer:        time.NewTimer(ttl),
                jobChanQueue: jobChanQueue,
                jobChan:      make(chan job),
                quit:         make(chan bool),
        }
}</span>

func (t *threadWorker) start() <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        t.jobChanQueue &lt;- t.jobChan

                        select </span>{
                        case job := &lt;-t.jobChan:<span class="cov0" title="0">
                                time.Sleep(job.delay)
                                func() </span><span class="cov0" title="0">{
                                        defer func() </span><span class="cov0" title="0">{
                                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                        fmt.Printf("Thread worker recovered from panic: %v\n", r)
                                                }</span>
                                        }()
                                        <span class="cov0" title="0">job.run()</span>
                                }()
                                <span class="cov0" title="0">t.timer.Reset(t.ttl)</span>
                        case &lt;-t.timer.C:<span class="cov0" title="0">
                                t.stop()
                                return</span>
                        case &lt;-t.quit:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
}

func (t *threadWorker) stop() <span class="cov0" title="0">{
        t.quit &lt;- true
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package observable

import (
        "context"

        "github.com/droxer/RxGo/internal/publisher"
)

// BridgeSubscriber adapts the new Reactive Streams Subscriber to the old Subscriber interface
type BridgeSubscriber[T any] struct {
        oldSubscriber Subscriber[T]
        subscription  publisher.Subscription
}

func NewBridgeSubscriber[T any](oldSub Subscriber[T]) *BridgeSubscriber[T] <span class="cov0" title="0">{
        return &amp;BridgeSubscriber[T]{
                oldSubscriber: oldSub,
        }
}</span>

func (bs *BridgeSubscriber[T]) OnSubscribe(s publisher.Subscription) <span class="cov0" title="0">{
        bs.subscription = s
        bs.oldSubscriber.Start()
        // Auto-request unlimited for backward compatibility
        s.Request(1 &lt;&lt; 62) // Max int64 value
}</span>

func (bs *BridgeSubscriber[T]) OnNext(t T) <span class="cov0" title="0">{
        bs.oldSubscriber.OnNext(t)
}</span>

func (bs *BridgeSubscriber[T]) OnError(err error) <span class="cov0" title="0">{
        bs.oldSubscriber.OnError(err)
}</span>

func (bs *BridgeSubscriber[T]) OnComplete() <span class="cov0" title="0">{
        bs.oldSubscriber.OnCompleted()
}</span>

// ObservablePublisher bridges old Observable to new Publisher
func ObservablePublisher[T any](obs *Observable[T]) publisher.Publisher[T] <span class="cov0" title="0">{
        return publisher.NewReactivePublisher(func(ctx context.Context, sub publisher.ReactiveSubscriber[T]) </span><span class="cov0" title="0">{
                // Create bridge subscriber to convert ReactiveSubscriber to old Subscriber
                bridge := &amp;bridgeFromReactive[T]{
                        reactiveSubscriber: sub,
                        ctx:                ctx,
                }

                // Use old Observable with the bridge
                obs.onSubscribe(ctx, bridge)
        }</span>)
}

// bridgeFromReactive adapts ReactiveSubscriber to old Subscriber interface
type bridgeFromReactive[T any] struct {
        reactiveSubscriber publisher.ReactiveSubscriber[T]
        ctx                context.Context
        subscription       publisher.Subscription
}

func (br *bridgeFromReactive[T]) Start() <span class="cov0" title="0">{
        // This is called by the old Observable system
        // We need to bridge from old to new
        br.reactiveSubscriber.OnSubscribe(br.subscription)
}</span>

func (br *bridgeFromReactive[T]) OnNext(t T) <span class="cov0" title="0">{
        br.reactiveSubscriber.OnNext(t)
}</span>

func (br *bridgeFromReactive[T]) OnError(err error) <span class="cov0" title="0">{
        br.reactiveSubscriber.OnError(err)
}</span>

func (br *bridgeFromReactive[T]) OnCompleted() <span class="cov0" title="0">{
        br.reactiveSubscriber.OnComplete()
}</span>

// PublisherObservable bridges new Publisher to old Observable
type PublisherObservable[T any] struct {
        publisher publisher.Publisher[T]
}

func NewPublisherObservable[T any](p publisher.Publisher[T]) *PublisherObservable[T] <span class="cov0" title="0">{
        return &amp;PublisherObservable[T]{publisher: p}
}</span>

func (po *PublisherObservable[T]) Subscribe(ctx context.Context, sub Subscriber[T]) <span class="cov0" title="0">{
        // Create bridge subscriber to convert from old Subscriber to new ReactiveSubscriber
        bridge := NewBridgeSubscriber[T](sub)
        po.publisher.Subscribe(ctx, bridge)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package observable

import (
        "context"
        "fmt"
        "runtime/debug"

        "github.com/droxer/RxGo/internal/scheduler"
)

// Subscriber is an interface for backward compatibility
type Subscriber[T any] interface {
        Start()
        OnNext(next T)
        OnCompleted()
        OnError(e error)
}

// Create creates a new Observable with the given OnSubscribe function.
func Create[T any](on OnSubscribe[T]) *Observable[T] <span class="cov8" title="1">{
        return &amp;Observable[T]{onSubscribe: on}
}</span>

// OnSubscribe defines the function signature for creating an Observable.
type OnSubscribe[T any] func(ctx context.Context, sub Subscriber[T])

// Observable represents a stream of values that can be observed.
type Observable[T any] struct {
        onSubscribe OnSubscribe[T]
}

// Subscribe starts the Observable and begins emitting values to the Subscriber.
func (o *Observable[T]) Subscribe(ctx context.Context, sub Subscriber[T]) <span class="cov8" title="1">{
        if sub == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Ensure context is not nil
        <span class="cov8" title="1">if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        // Start the subscriber
        <span class="cov8" title="1">sub.Start()

        // Ensure panic recovery
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        debug.PrintStack()
                        sub.OnError(fmt.Errorf("panic in observable: %v", r))
                }</span>
        }()

        // Execute the subscription
        <span class="cov8" title="1">o.onSubscribe(ctx, sub)</span>
}

// Just creates an Observable that emits the provided values.
func Just[T any](values ...T) *Observable[T] <span class="cov0" title="0">{
        return Create(func(ctx context.Context, sub Subscriber[T]) </span><span class="cov0" title="0">{
                defer sub.OnCompleted()
                for _, value := range values </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                sub.OnError(ctx.Err())
                                return</span>
                        default:<span class="cov0" title="0">
                                sub.OnNext(value)</span>
                        }
                }
        })
}

// Range creates an Observable that emits integers in the specified range.
func Range(start, count int) *Observable[int] <span class="cov0" title="0">{
        return Create(func(ctx context.Context, sub Subscriber[int]) </span><span class="cov0" title="0">{
                defer sub.OnCompleted()
                if count &lt;= 0 </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                sub.OnError(ctx.Err())
                                return</span>
                        default:<span class="cov0" title="0">
                                sub.OnNext(start + i)</span>
                        }
                }
        })
}

// ObserveOn schedules the Observable to emit its values on the specified scheduler.
func (o *Observable[T]) ObserveOn(scheduler scheduler.Scheduler) *Observable[T] <span class="cov0" title="0">{
        return Create(func(ctx context.Context, sub Subscriber[T]) </span><span class="cov0" title="0">{
                o.Subscribe(ctx, &amp;observeOnSubscriber[T]{
                        scheduler: scheduler,
                        sub:       sub,
                        ctx:       ctx,
                })
        }</span>)
}

// observeOnSubscriber wraps a subscriber for scheduling

type observeOnSubscriber[T any] struct {
        scheduler scheduler.Scheduler
        sub       Subscriber[T]
        ctx       context.Context
        started   bool
}

func (o *observeOnSubscriber[T]) Start() <span class="cov0" title="0">{
        if !o.started </span><span class="cov0" title="0">{
                o.started = true
                o.scheduler.Schedule(func() </span><span class="cov0" title="0">{
                        o.sub.Start()
                }</span>)
        }
}

func (o *observeOnSubscriber[T]) OnNext(t T) <span class="cov0" title="0">{
        o.scheduler.Schedule(func() </span><span class="cov0" title="0">{
                if o.ctx.Err() != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">o.sub.OnNext(t)</span>
        })
}

func (o *observeOnSubscriber[T]) OnError(err error) <span class="cov0" title="0">{
        o.scheduler.Schedule(func() </span><span class="cov0" title="0">{
                if o.ctx.Err() != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">o.sub.OnError(err)</span>
        })
}

func (o *observeOnSubscriber[T]) OnCompleted() <span class="cov0" title="0">{
        o.scheduler.Schedule(func() </span><span class="cov0" title="0">{
                if o.ctx.Err() != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">o.sub.OnCompleted()</span>
        })
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package rxgo provides the main entry point for the RxGo library.
package rxgo

import (
        "context"

        "github.com/droxer/RxGo/internal/publisher"
        "github.com/droxer/RxGo/pkg/observable"
)

// NewReactivePublisher creates a new Publisher with Reactive Streams compliance
func NewReactivePublisher[T any](onSubscribe func(ctx context.Context, sub publisher.ReactiveSubscriber[T])) publisher.Publisher[T] <span class="cov0" title="0">{
        return publisher.NewReactivePublisher(onSubscribe)
}</span>

// FromSlice creates a Publisher from a slice of values
func FromSlice[T any](items []T) publisher.Publisher[T] <span class="cov0" title="0">{
        return publisher.FromSlice(items)
}</span>

// RangePublisher creates a Publisher that emits a range of integers
func RangePublisher(start, count int) publisher.Publisher[int] <span class="cov0" title="0">{
        return publisher.RangePublisher(start, count)
}</span>

// Create creates an Observable using the legacy API
func Create[T any](onSubscribe func(ctx context.Context, sub observable.Subscriber[T])) *observable.Observable[T] <span class="cov0" title="0">{
        return observable.Create(onSubscribe)
}</span>

// Just creates an Observable that emits the provided values
func Just[T any](values ...T) *observable.Observable[T] <span class="cov0" title="0">{
        return observable.Just(values...)
}</span>

// Range creates an Observable that emits integers in the specified range
func Range(start, count int) *observable.Observable[int] <span class="cov0" title="0">{
        return observable.Range(start, count)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
